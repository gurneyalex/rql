/******************************************************************
 * File: rql_scanner.hh
 *
 * This file was automatically generated by CppCC Version 0.0.8
 * DO NOT EDIT MANUALLY
 ******************************************************************/


#ifndef __RQL_SCANNER_HH__
#define __RQL_SCANNER_HH__

#include <string>
#include <fstream>
#include <iostream>
#include <exception>
#include <stack>

#include "rql_token.hh"

namespace cppcc
{

class ScanException : public std::exception
{
  public:
    
    ScanException (const std::string &message_ = "Scan exception") :
      message(message_)
    {}
    
    ScanException (const Position &pos_,
                   const std::string &message_ = "Scan exception") :
      message(message_), pos(pos_)
    {}
    
    ~ScanException () throw ()
    {}
    
    virtual operator std::string () const
    {
      return std::string(pos) + ": " + message;
    }
    
    virtual const char* what () const throw ()
    {
      return message.c_str();
    }
    
  private:
  
    std::string message;
    Position pos;
};

class RqlScanner_base
{
  protected:
    bool onScanError (ScanException &ex) { return false; }
    bool onIOError (ScanException &ex) { return false; }
    bool wrap () { return false; }
    void commonTokenAction (RqlToken &tok) {}
    void onInit () {}
    void onDestroy () {}
};

class RqlScanner: public RqlScanner_base
{
public:
  
  struct t_laCell
  {
    RqlToken *token;
    struct t_laCell *next;
    t_laCell(RqlToken *token_, struct t_laCell *next_) : token(token_), next(next_) {}
    ~t_laCell() { delete token; }
  };
  
  RqlScanner (std::istream *in_ = NULL) throw (ScanException)
      : _reject(false), _more(false), _buffer(NULL),
  _bsz(8 * 1024), _pbsz(100)
  {
    switchToStream(in_);
    lookahead = false;
    la0 = _laBegin = _laEnd = new struct t_laCell(new RqlToken, NULL);
    la0->next = la0;
    switchToState(START);
    onInit();
  }
  
  ~RqlScanner ()
  {
    if (_buffer) delete[] _buffer;
    for (t_laCell *p = _laEnd->next, *q; p != _laEnd; p = q)
    {
      q = p->next;
      delete p;
    }
    delete _laEnd;
    onDestroy();
  }
  
  void rejectToken() {_reject = true; }
  
  void switchToStream (std::istream *in)
  {
    resetPos();
    inputStream = in;
    _binit();
  }
  
  class StreamState
  {
    friend class RqlScanner;
    std::istream *inputStream;
    char *_buffer;
    int _bsz;
    int _pbsz;
    char *_start;
    char * _bol;
    char *_ch;
    char *_eob;
    bool _lta;
    bool _eof;
    Position bPos, ePos;
    
    StreamState (std::istream *inputStream_, char *_buffer_, int _bsz_,
                int _pbsz_, char *_start_, char *_bol_, char *_ch_,
                 char *_eob_, bool _lta_, bool _eof_,
                 Position &bPos_, Position &ePos_) :
      inputStream(inputStream_), _buffer(_buffer_), _bsz(_bsz_),
        _pbsz(_pbsz_), _start(_start_), _bol(_bol_), _ch(_ch_),
       _eob(_eob_), _lta(_lta_), _eof(_eof_),
       bPos(bPos_), ePos(ePos_)
    {}
    
    ~StreamState () { if (_buffer != NULL) delete[] _buffer; }
  };
  
  StreamState* pushStream (std::istream *in)
  {
    StreamState *res = new StreamState(inputStream, _buffer, _bsz,
                        _pbsz, _more ? _start : _ch, _bol, _ch,
                                       _eob, _lta, _eof,
                                     _more ? bPos : ePos, ePos);
    _buffer = NULL;
    switchToStream(in);
    return res;
  }
  
  void popStream (StreamState *s)
  {
    if (_buffer != NULL) delete[] _buffer;
    inputStream = s->inputStream;
    _buffer = s->_buffer;
    _bsz = s->_bsz;
    _pbsz = s->_pbsz;
    _start = s->_start;
    _bol = s->_bol;
    _ch = s->_ch;
    _eob = s->_eob;
    _lta = s->_lta;
    _eof = s->_eof;
    bPos = s->bPos;
    ePos = s->ePos;
    s->_buffer = NULL;
    delete s;
  }
  
  std::istream& getInputStream ()
  {
    return *inputStream;
  }
  
  int switchToState (int newState)
  {
    int prevState = _state;
    _state = newState;
    return prevState;
  }
  
  int getState ()
  {
    return _state;
  }
  
  int pushState (int newState)
  {
    _stateStack.push(_state);
    return switchToState(newState);
  }
  
  int popState ()
  {
    int prevState = switchToState(_stateStack.top());
    _stateStack.pop();
    return prevState;
  }
  
  const Position& getCurrentPos ()
  {
    return bPos;
  }
  
  void resetPos ()
  {
    ePos.ln = bPos.ln = 1;
    bPos.col = ePos.col = 1;
    _bol = _ch;
  }
  
  int newLine ()
  {
    _bol = _ch;
    ePos.col = 1;
    return ePos.ln++;
  }
  
  bool lookingAhead ()
  {
    return lookahead;
  }
  
  int getChar () throw (ScanException)
  {
    for(;;) {
      unsigned int c = *_ch++;
      if (_ch == _eob) {
        _ch--;
        if (_eof && !wrap()) return EOF;
        else _brefill();
      } else {
        if (_start == _ch - 1) _start = _ch;
        return c;
      }
    }
  }
  
  void unGetChars (const char *c, int n);
  void unGetChar (char c)
  {
    unGetChars(&c, 1);
  }
  
  void unGetChars (const std::string &s)
  {
    unGetChars(s.data(), s.length());
  }
  
  void unGetChars (const char *s)
  {
    unGetChars(s, strlen(s));
  }
  
  RqlToken* la (int k) throw (ScanException)
  {
    struct t_laCell *p, *q;
    for (p = la0; k >= 0; k--, q = p, p = p->next) {
      if (p == _laEnd) {
        if (_laEnd->next == _laBegin)
          _laEnd->next = new struct t_laCell(new RqlToken(), _laBegin);
        _scan(_laEnd->token);
        _laEnd = _laEnd->next;
      }
    }
    return q->token;
  }
  
  RqlToken* la () throw (ScanException)
  {
    if (la0 == _laEnd) {
      if (_laEnd->next == _laBegin)
        _laEnd->next = new struct t_laCell(new RqlToken(), _laBegin);
      _scan(_laEnd->token);
      _laEnd = _laEnd->next;
    }
    return la0->token;
  }
  
  void consume () throw (ScanException)
  {
    la();
    la0 = la0->next;
    if (!lookahead)
      _laBegin = _laBegin->next;
  }
  
  void unchecked_consume ()
  {
    la0 = la0->next;
    if (!lookahead)
      _laBegin = _laBegin->next;
  }
  
  void setMarker ()
  {
    lookahead = true;
    laMarkers.push(la0);
  }
  
  void rewindToMarker ()
  {
    la0 = laMarkers.top();
    laMarkers.pop();
    if (laMarkers.empty()) {
      lookahead = false;
      _laBegin = la0;
    }
  }
  
  
  static const int START;
  static const int LONG_COMMENT;
  
protected: // the ugly stuff

  void _scan(RqlToken *token) throw (ScanException);
  Position bPos, ePos;
  std::istream *inputStream;
  
  bool lookahead;
  struct t_laCell *la0, *_laBegin, *_laEnd;
  std::stack<struct t_laCell*> laMarkers;
  int _state;
  std::stack<int> _stateStack;
  bool _reject;
  bool _more; // true in token actions of MORE tokens
  
  void _brefill () throw (ScanException);
  void _binit() throw (ScanException);
  char *_buffer;
  int _bsz; //buffer size
  int _pbsz; //extra bytes for pushback
  char *_ch; // current char
  char *_eob; // one past the last char in the buffer
  char *_start; // points ot the token's start
  bool _eof; // eof seen during _brefill
  bool _lta; // last token in the stream was accepted
  char * _bol; // _ch - _bol = col increment.
  
private: // user code

#line 43 "rql.cg"

    public:
	void skipTo( const std::string& tok )
	    {
		RqlToken* token = la();
		while( !_eof && token->image()!=tok ) {
		    consume();
		}
	    }
	std::streampos getStreamPos()
	    {
		std::streampos pos;
		if (!_eof) {
		    pos = inputStream->tellg() - std::streampos(_eob-_ch);
		    if (pos<0) 
			return std::streampos(0);
		    return pos;
		} else {
		    inputStream->clear();
		    inputStream->seekg (0, std::ios::end);
		    return inputStream->tellg() - std::streampos(_eob-_ch);
		}
	    }
	bool is_next_vars_decl() {
	    RqlToken* _la;
	    _la = la();
	    if ( is_e_type(_la->image()) ) {
		_la = la(1);
		if ( is_var( _la->image() ) ) {
		    return true;
		}
	    }
	    return false;
	}
    
#line 379 "rql_scanner.hh"


}; // end class RqlScanner


} //end namespace cppcc

#endif // ifndef __RQL_SCANNER_HH__


/* End of file. */
